<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CompletableFuture使用详解</title>
    <url>/2022/12/04/CompletableFuture%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="一、创建异步任务"><a href="#一、创建异步任务" class="headerlink" title="一、创建异步任务"></a>一、创建异步任务</h2><h3 id="1-supplyAsync"><a href="#1-supplyAsync" class="headerlink" title="1. supplyAsync"></a>1. supplyAsync</h3><p>supplyAsync是创建带有返回值的异步任务。它有如下两个方法，一个是使用默认<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E6%B1%A0&spm=1001.2101.3001.7020">线程池</a>（ForkJoinPool.commonPool()）的方法，一个是带有自定义线程池的重载方法。<span id="more"></span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 带返回值异步请求，默认线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 带返回值的异步请求，可以自定义线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; cf = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;do something....&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;result&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//等待任务执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;结果-&gt;&quot;</span> + cf.get());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 自定义线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        CompletableFuture&lt;String&gt; cf = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;do something....&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;result&quot;</span>;</span><br><span class="line">        &#125;, executorService);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//等待子任务执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;结果-&gt;&quot;</span> + cf.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://img-blog.csdnimg.cn/2554e01f6ab24c0181d55f5c5920533a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pCs56CW6ICB5Yac5bel,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h3 id="2-runAsync"><a href="#2-runAsync" class="headerlink" title="2.runAsync"></a>2.runAsync</h3><p>runAsync是创建没有返回值的异步任务。它有如下两个方法，一个是使用默认线程池（ForkJoinPool.commonPool()）的方法，一个是带有自定义线程池的重载方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不带返回值的异步请求，默认线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不带返回值的异步请求，可以自定义线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span></span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; cf = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;do something....&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//等待任务执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;结果-&gt;&quot;</span> + cf.get());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 自定义线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        CompletableFuture&lt;Void&gt; cf = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;do something....&quot;</span>);</span><br><span class="line">        &#125;, executorService);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//等待任务执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;结果-&gt;&quot;</span> + cf.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-获取任务结果的方法"><a href="#3-获取任务结果的方法" class="headerlink" title="3.获取任务结果的方法"></a>3.获取任务结果的方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果完成则返回结果，否则就抛出具体的异常</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 最大时间等待返回结果，否则就抛出具体异常</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 完成时返回结果值，否则抛出unchecked异常。为了更好地符合通用函数形式的使用，如果完成此 CompletableFuture所涉及的计算引发异常，则此方法将引发unchecked异常并将底层异常作为其原因</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">join</span><span class="params">()</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果完成则返回结果值（或抛出任何遇到的异常），否则返回给定的 valueIfAbsent。</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getNow</span><span class="params">(T valueIfAbsent)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果任务没有完成，返回的值设置为给定值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">complete</span><span class="params">(T value)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果任务没有完成，就抛出给定异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">completeExceptionally</span><span class="params">(Throwable ex)</span> </span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<h2 id="二、异步回调处理"><a href="#二、异步回调处理" class="headerlink" title="二、异步回调处理"></a>二、异步回调处理</h2><h3 id="1-thenApply和thenApplyAsync"><a href="#1-thenApply和thenApplyAsync" class="headerlink" title="1.thenApply和thenApplyAsync"></a>1.thenApply和thenApplyAsync</h3><p>thenApply 表示某个任务执行完成后执行的动作，即回调方法，会将该任务的执行结果即方法返回值作为入参传递到回调方法中，带有返回值。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf1 do something....&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf2 = cf1.thenApplyAsync((result) -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf2 do something....&quot;</span>);</span><br><span class="line">            result += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//等待任务1执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;cf1结果-&gt;&quot;</span> + cf1.get());</span><br><span class="line">        <span class="comment">//等待任务2执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;cf2结果-&gt;&quot;</span> + cf2.get());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf1 do something....&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf2 = cf1.thenApply((result) -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf2 do something....&quot;</span>);</span><br><span class="line">            result += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//等待任务1执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;cf1结果-&gt;&quot;</span> + cf1.get());</span><br><span class="line">        <span class="comment">//等待任务2执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;cf2结果-&gt;&quot;</span> + cf2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img data-src="https://img-blog.csdnimg.cn/1b4d3fd6b64c408fb08bbb12123bc1dd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pCs56CW6ICB5Yac5bel,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img data-src="https://img-blog.csdnimg.cn/bf7eff437f11456984c1f5fa1a65494b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pCs56CW6ICB5Yac5bel,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>从上面代码和测试结果我们发现thenApply和thenApplyAsync区别在于，使用thenApply方法时子任务与父任务使用的是同一个线程，而thenApplyAsync在子任务中是另起一个线程执行任务，并且thenApplyAsync可以自定义线程池，默认的使用ForkJoinPool.commonPool()线程池。  </p>
<h3 id="2-thenAccept和thenAcceptAsync"><a href="#2-thenAccept和thenAcceptAsync" class="headerlink" title="2.thenAccept和thenAcceptAsync"></a>2.thenAccept和thenAcceptAsync</h3><p>thenAccep表示某个任务执行完成后执行的动作，即回调方法，会将该任务的执行结果即方法返回值作为入参传递到回调方法中，无返回值。</p>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf1 do something....&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        CompletableFuture&lt;Void&gt; cf2 = cf1.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf2 do something....&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//等待任务1执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;cf1结果-&gt;&quot;</span> + cf1.get());</span><br><span class="line">        <span class="comment">//等待任务2执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;cf2结果-&gt;&quot;</span> + cf2.get());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf1 do something....&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        CompletableFuture&lt;Void&gt; cf2 = cf1.thenAcceptAsync((result) -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf2 do something....&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//等待任务1执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;cf1结果-&gt;&quot;</span> + cf1.get());</span><br><span class="line">        <span class="comment">//等待任务2执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;cf2结果-&gt;&quot;</span> + cf2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img data-src="https://img-blog.csdnimg.cn/e09614f117094276a80505ac3ddec84e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pCs56CW6ICB5Yac5bel,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>从上面代码和测试结果我们发现thenAccep和thenAccepAsync区别在于，使用thenAccep方法时子任务与父任务使用的是同一个线程，而thenAccepAsync在子任务中可能是另起一个线程执行任务，并且thenAccepAsync可以自定义线程池，默认的使用ForkJoinPool.commonPool()线程池。</p>
<h3 id="2-thenRun和thenRunAsync"><a href="#2-thenRun和thenRunAsync" class="headerlink" title="2.thenRun和thenRunAsync"></a>2.thenRun和thenRunAsync</h3><p> thenRun表示某个任务执行完成后执行的动作，即回调方法，无入参，无返回值。</p>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf1 do something....&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        CompletableFuture&lt;Void&gt; cf2 = cf1.thenRun(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf2 do something....&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//等待任务1执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;cf1结果-&gt;&quot;</span> + cf1.get());</span><br><span class="line">        <span class="comment">//等待任务2执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;cf2结果-&gt;&quot;</span> + cf2.get());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf1 do something....&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        CompletableFuture&lt;Void&gt; cf2 = cf1.thenRunAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf2 do something....&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//等待任务1执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;cf1结果-&gt;&quot;</span> + cf1.get());</span><br><span class="line">        <span class="comment">//等待任务2执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;cf2结果-&gt;&quot;</span> + cf2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img data-src="https://img-blog.csdnimg.cn/59c01a23b6534855bb73d9b347c091ee.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pCs56CW6ICB5Yac5bel,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>可以发现thenRun和thenRunAsync区别在于，使用thenRun方法时子任务与父任务使用的是同一个线程，而thenRunAsync在子任务中可能是另起一个线程执行任务，并且thenRunAsync可以自定义线程池，默认的使用ForkJoinPool.commonPool()线程池。</p>
<h3 id="3-whenComplete和whenCompleteAsync"><a href="#3-whenComplete和whenCompleteAsync" class="headerlink" title="3.whenComplete和whenCompleteAsync"></a>3.whenComplete和whenCompleteAsync</h3><p> whenComplete是当某个任务执行完成后执行的回调方法，会将执行结果或者执行期间抛出的异常传递给回调方法，如果是正常执行则异常为null，回调方法对应的CompletableFuture的result和该任务一致，如果该任务正常执行，则get方法返回执行结果，如果是执行异常，则get方法抛出异常。  </p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf1 do something....&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf2 = cf1.whenComplete((result, e) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;上个任务结果：&quot;</span> + result);</span><br><span class="line">            System.out.println(<span class="string">&quot;上个任务抛出异常：&quot;</span> + e);</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf2 do something....&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//        //等待任务1执行完成</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;cf1结果-&gt;&quot; + cf1.get());</span></span><br><span class="line"><span class="comment">//        //等待任务2执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;cf2结果-&gt;&quot;</span> + cf2.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img data-src="https://img-blog.csdnimg.cn/06a453f55ad349ffb99cd0fb608541d9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pCs56CW6ICB5Yac5bel,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>whenCompleteAsync和whenComplete区别也是whenCompleteAsync可能会另起一个线程执行任务，并且thenRunAsync可以自定义线程池，默认的使用ForkJoinPool.commonPool()线程池。</p>
<h3 id="4-handle和handleAsync"><a href="#4-handle和handleAsync" class="headerlink" title="4.handle和handleAsync"></a>4.handle和handleAsync</h3><p>跟whenComplete基本一致，区别在于handle的回调方法有返回值。</p>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf1 do something....&quot;</span>);</span><br><span class="line">            <span class="comment">// int a = 1/0;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf2 = cf1.handle((result, e) -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf2 do something....&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;上个任务结果：&quot;</span> + result);</span><br><span class="line">            System.out.println(<span class="string">&quot;上个任务抛出异常：&quot;</span> + e);</span><br><span class="line">            <span class="keyword">return</span> result+<span class="number">2</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//等待任务2执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;cf2结果-&gt;&quot;</span> + cf2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试结果 ：</p>
<p><img data-src="https://img-blog.csdnimg.cn/6862664a43314e32905ab2272a745d73.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pCs56CW6ICB5Yac5bel,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h2 id="三、多任务组合处理"><a href="#三、多任务组合处理" class="headerlink" title="三、多任务组合处理"></a>三、多任务组合处理</h2><h3 id="1-thenCombine、thenAcceptBoth-和runAfterBoth"><a href="#1-thenCombine、thenAcceptBoth-和runAfterBoth" class="headerlink" title="1.thenCombine、thenAcceptBoth 和runAfterBoth"></a>1.thenCombine、thenAcceptBoth 和runAfterBoth</h3><p>这三个方法都是将两个CompletableFuture组合起来处理，只有两个任务都正常完成时，才进行下阶段任务。</p>
<p>区别：thenCombine会将两个任务的执行结果作为所提供函数的参数，且该方法有返回值；thenAcceptBoth同样将两个任务的执行结果作为方法入参，但是无返回值；runAfterBoth没有入参，也没有返回值。注意两个任务中只要有一个执行异常，则将该异常信息作为指定任务的执行结果。</p>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf1 do something....&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf2 do something....&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf3 = cf1.thenCombine(cf2, (a, b) -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf3 do something....&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;cf3结果-&gt;&quot;</span> + cf3.get());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf1 do something....&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf2 do something....&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture&lt;Void&gt; cf3 = cf1.thenAcceptBoth(cf2, (a, b) -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf3 do something....&quot;</span>);</span><br><span class="line">            System.out.println(a + b);</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;cf3结果-&gt;&quot;</span> + cf3.get());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf1 do something....&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf2 do something....&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        CompletableFuture&lt;Void&gt; cf3 = cf1.runAfterBoth(cf2, () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf3 do something....&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;cf3结果-&gt;&quot;</span> + cf3.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试结果：</p>
<p><img data-src="https://img-blog.csdnimg.cn/b4adbd9376294821a623bc3a0dd333f0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pCs56CW6ICB5Yac5bel,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img data-src="https://img-blog.csdnimg.cn/c05396dfb47f41fa8fb2218bceed606e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pCs56CW6ICB5Yac5bel,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img data-src="https://img-blog.csdnimg.cn/2b39eb2a10b641b7b857ecf5b058e0ee.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pCs56CW6ICB5Yac5bel,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h3 id="2-applyToEither、acceptEither和runAfterEither"><a href="#2-applyToEither、acceptEither和runAfterEither" class="headerlink" title="2.applyToEither、acceptEither和runAfterEither"></a>2.applyToEither、acceptEither和runAfterEither</h3><p>这三个方法和上面一样也是将两个CompletableFuture组合起来处理，当有一个任务正常完成时，就会进行下阶段任务。</p>
<p>区别：applyToEither会将已经完成任务的执行结果作为所提供函数的参数，且该方法有返回值；acceptEither同样将已经完成任务的执行结果作为方法入参，但是无返回值；runAfterEither没有入参，也没有返回值。</p>
<h3 id="3-allOf-anyOf"><a href="#3-allOf-anyOf" class="headerlink" title="3.allOf / anyOf"></a>3.allOf / anyOf</h3><p>allOf：CompletableFuture是多个任务都执行完成后才会执行，只有有一个任务执行异常，则返回的CompletableFuture执行get方法时会抛出异常，如果都是正常执行，则get返回null。</p>
<p>anyOf ：CompletableFuture是多个任务只要有一个任务执行完成，则返回的CompletableFuture执行get方法时会抛出异常，如果都是正常执行，则get返回执行完成任务的结果。</p>
]]></content>
      <tags>
        <tag>CompletableFuture</tag>
      </tags>
  </entry>
</search>
